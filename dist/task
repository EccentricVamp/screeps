'use strict';

require('lodash');
var act = require('./act');
var creep = require('./creep');

class Build {
    constructor(build, energize) {
        this.acts = [build, energize];
        this.parts = act.getParts(this.acts);
    }
    perform(creep$1) {
        const BUILD = 0;
        const ENERGIZE = 1;
        const status = creep.getStatus(creep$1, [BUILD, ENERGIZE]);
        const act = this.acts[status];
        switch (act.execute(creep$1)) {
            case ERR_NOT_IN_RANGE:
                creep.moveTo(creep$1, act.target);
                break;
            case ERR_NOT_ENOUGH_ENERGY:
                creep.setStatus(creep$1, ENERGIZE);
                break;
            case ERR_FULL:
                creep.setStatus(creep$1, BUILD);
                break;
        }
    }
}

class Claim {
    constructor(claim) {
        this.acts = [claim];
        this.parts = act.getParts(this.acts);
    }
    perform(creep$1) {
        const CLAIM = 0;
        const act = this.acts[CLAIM];
        switch (act.execute(creep$1)) {
            case ERR_NOT_IN_RANGE:
                creep.moveTo(creep$1, act.target);
                break;
        }
    }
}

class Harvest {
    constructor(harvest, transfer) {
        this.parts = [WORK, WORK, WORK, CARRY, MOVE];
        this.acts = [harvest, transfer];
    }
    perform(creep$1) {
        const HARVEST = 0;
        const TRANSFER = 1;
        const status = creep.getStatus(creep$1, [HARVEST, TRANSFER]);
        const act = this.acts[status];
        switch (act.execute(creep$1)) {
            case ERR_NOT_IN_RANGE:
                creep.moveTo(creep$1, act.target);
                break;
            case ERR_NOT_ENOUGH_RESOURCES:
                creep.setStatus(creep$1, HARVEST);
                break;
            case ERR_FULL:
                creep.setStatus(creep$1, TRANSFER);
                break;
        }
    }
}

class Idle {
    constructor(target) {
        this.acts = [];
        this.parts = [MOVE];
        this.target = target;
    }
    perform(creep) {
        creep.moveTo(this.target);
    }
}

const RECYCLE = 98;
class Recycle {
    constructor(recycle) {
        this.parts = [];
        this.acts = [recycle];
    }
    perform(creep$1) {
        creep.setStatus(creep$1, RECYCLE);
        const act = this.acts[0];
        switch (act.execute(creep$1)) {
            case ERR_NOT_IN_RANGE:
                creep.moveTo(creep$1, act.target);
                break;
        }
    }
}

const RENEW = 99;
const THRESHOLD = 500;
class Renew {
    constructor(renew) {
        this.parts = [];
        this.acts = [renew];
    }
    perform(creep$1) {
        creep.setStatus(creep$1, RENEW);
        const act = this.acts[0];
        switch (act.execute(creep$1)) {
            case ERR_NOT_IN_RANGE:
                creep.moveTo(creep$1, act.target);
                break;
            case ERR_FULL:
                creep.setStatus(creep$1, null);
                break;
        }
    }
}

class Transfer {
    constructor(transfer, collect) {
        this.acts = [transfer, collect];
        this.parts = act.getParts(this.acts);
    }
    perform(creep$1) {
        const TRANSFER = 0;
        const COLLECT = 1;
        const status = creep.getStatus(creep$1, [TRANSFER, COLLECT]);
        const act = this.acts[status];
        switch (act.execute(creep$1)) {
            case ERR_NOT_IN_RANGE:
                creep.moveTo(creep$1, act.target);
                break;
            case ERR_NOT_ENOUGH_RESOURCES:
                creep.setStatus(creep$1, COLLECT);
                break;
            case ERR_FULL:
                creep.setStatus(creep$1, TRANSFER);
                break;
        }
    }
}

class Repair {
    constructor(repair, energize) {
        this.acts = [repair, energize];
        this.parts = act.getParts(this.acts);
    }
    perform(creep$1) {
        const REPAIR = 0;
        const ENERGIZE = 1;
        const status = creep.getStatus(creep$1, [REPAIR, ENERGIZE]);
        const act = this.acts[status];
        switch (act.execute(creep$1)) {
            case ERR_NOT_IN_RANGE:
                creep.moveTo(creep$1, act.target);
                break;
            case ERR_NOT_ENOUGH_ENERGY:
                creep.setStatus(creep$1, ENERGIZE);
                break;
            case ERR_FULL:
                creep.setStatus(creep$1, REPAIR);
                break;
        }
    }
}

class Upgrade {
    constructor(upgrade, energize) {
        this.acts = [upgrade, energize];
        this.parts = act.getParts(this.acts);
    }
    perform(creep$1) {
        const UPGRADE = 0;
        const ENERGIZE = 1;
        const status = creep.getStatus(creep$1, [UPGRADE, ENERGIZE]);
        const act = this.acts[status];
        switch (act.execute(creep$1)) {
            case ERR_NOT_IN_RANGE:
                creep.moveTo(creep$1, act.target);
                break;
            case ERR_NOT_ENOUGH_ENERGY:
                creep.setStatus(creep$1, ENERGIZE);
                break;
            case ERR_FULL:
                creep.setStatus(creep$1, UPGRADE);
                break;
        }
        return false;
    }
}

class Factory {
    static Build(site, collect) {
        return new Build(new act.Build(site), collect);
    }
    static Claim(controller) {
        return new Claim(new act.Claim(controller));
    }
    static Harvest(target, store) {
        return new Harvest(new act.Harvest(target), new act.Transfer(store));
    }
    static Idle(target) {
        return new Idle(target.pos);
    }
    static Recycle(spawn) {
        return new Recycle(new act.Recycle(spawn));
    }
    static Renew(spawn) {
        return new Renew(new act.Renew(spawn));
    }
    static Transfer(target, collect) {
        return new Transfer(new act.Transfer(target), collect);
    }
}

exports.Build = Build;
exports.Claim = Claim;
exports.Factory = Factory;
exports.Harvest = Harvest;
exports.Idle = Idle;
exports.RECYCLE = RECYCLE;
exports.RENEW = RENEW;
exports.Recycle = Recycle;
exports.Renew = Renew;
exports.Repair = Repair;
exports.THRESHOLD = THRESHOLD;
exports.Transfer = Transfer;
exports.Upgrade = Upgrade;
