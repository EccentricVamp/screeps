'use strict';

var lodash = require('lodash');
var act = require('./act');
var creep = require('./creep');
var filter = require('./filter');
var task = require('./task');

function maintain(room) {
    const spawns = room.find(FIND_MY_SPAWNS);
    const creeps = room.find(FIND_MY_CREEPS);
    const structures = room.find(FIND_STRUCTURES);
    const resources = room.find(FIND_DROPPED_RESOURCES);
    const controller = room.controller;
    if (spawns.length > 0) {
        const spawn = spawns[0];
        const recycle = task.Factory.Recycle(spawn);
        const renew = task.Factory.Renew(spawn);
        for (const creep of creeps) {
            const status = creep.memory.status;
            if (status === task.RECYCLE) {
                recycle.perform(creep);
                lodash.pull(creeps, creep);
                continue;
            }
            // Ignore creeps with CLAIM parts
            if (creep.body.some(part => part.type === CLAIM))
                continue;
            // Ignore spawning creeps
            if (creep.ticksToLive === undefined)
                continue;
            if (creep.ticksToLive < task.THRESHOLD || status === task.RENEW) {
                renew.perform(creep);
                if (creep.memory.status !== null)
                    lodash.pull(creeps, creep);
            }
        }
    }
    const tasks = new Array();
    if (controller !== undefined && !controller.my) {
        tasks.push(task.Factory.Claim(controller));
    }
    const energyNeeds = structures.filter(filter.needsEnergy);
    const energyStores = structures.filter(filter.hasEnergy);
    const energyResources = resources.filter(filter.isEnergy);
    const energySources = room.find(FIND_SOURCES_ACTIVE);
    if (energyNeeds.length > 0) {
        const need = energyNeeds[0];
        const collect = findEnergy(energyResources, energyStores, energySources);
        if (collect !== null) {
            tasks.push(task.Factory.Transfer(need, collect));
        }
    }
    const energyCapacity = structures.filter(filter.hasCapacity);
    if (energyCapacity.length > 0) {
        const capacity = energyCapacity[0];
        const source = lodash.first(lodash.sortBy(energySources, s => s.pos.getRangeTo(capacity)));
        if (source !== undefined) {
            lodash.pull(energySources, source);
            tasks.push(task.Factory.Harvest(source, capacity));
        }
    }
    const sites = room.find(FIND_CONSTRUCTION_SITES);
    if (sites.length > 0) {
        const site = sites[0];
        const collect = findEnergy(energyResources, energyStores, energySources);
        if (collect !== null) {
            tasks.push(task.Factory.Build(site, collect));
        }
    }
    for (const task of tasks) {
        if (creeps.length === 0)
            break;
        const creep = evaluate(creeps, task);
        if (creep === undefined)
            continue;
        lodash.pull(creeps, creep);
        task.perform(creep);
    }
    if (Game.flags.Idle !== undefined) {
        const idle = task.Factory.Idle(Game.flags.Idle);
        for (const creep of creeps) {
            idle.perform(creep);
        }
    }
}
/** Get the best creep for a given task. */
function evaluate(creeps, task) {
    const parts = task.parts;
    const evaluations = creeps
        .map(creep$1 => new creep.Evaluation(creep$1, parts))
        .filter(evaluation => evaluation.eligible)
        .sort((a, b) => a.score - b.score);
    return evaluations[evaluations.length - 1].creep;
}
function findEnergy(resources, stores, sources) {
    if (resources.length > 0) {
        const resource = resources.pop();
        return new act.Pickup(resource);
    }
    else if (stores.length > 0) {
        const store = stores.pop();
        return new act.Withdraw(store);
    }
    else if (sources.length > 0) {
        const source = sources.pop();
        return new act.Harvest(source);
    }
    else
        return null;
}
const loop = () => {
    for (const room of Object.values(Game.rooms)) {
        maintain(room);
    }
    for (const name in Memory.creeps) {
        if (!(name in Game.creeps)) {
            delete Memory.creeps[name];
        }
    }
};

exports.loop = loop;
